# Gypsophila AI 后端模块使用指南

本文档详细介绍各模块的API和使用方法，帮助开发者快速上手和正确使用系统功能。

## 目录

- [配置模块](#配置模块)
- [日志模块](#日志模块)
- [数据库模块](#数据库模块)
- [Redis模块](#redis模块)
- [认证模块](#认证模块)

## 配置模块

### 基本用法

```typescript
import { Injectable } from '@nestjs/common';
import { ConfigService } from '../config/config.service';

@Injectable()
export class ExampleService {
  constructor(private readonly configService: ConfigService) {}

  someMethod() {
    // 获取配置
    const dbConfig = this.configService.get('database');

    // 获取嵌套配置
    const jwtSecret = this.configService.get('jwt', 'secret');
  }
}
```

### 环境变量定义

所有环境变量应在`src/config/config.schema.ts`中定义并验证，例如：

```typescript
export const configValidationSchema = Joi.object({
  NODE_ENV: Joi.string()
    .valid('development', 'production', 'test')
    .default('development'),
  PORT: Joi.number().default(3000),
  // 数据库配置
  DATABASE_HOST: Joi.string().required(),
  DATABASE_PORT: Joi.number().default(5432),
  // ...其他配置项
});
```

### 配置文件

配置文件应放置在`config`目录下，采用 `yaml` 作为配置文件，例如：

```
config/
  |- app.production.yaml（生产环境）
  |- app.test.yaml（测试环境）
  |- app.yaml（开发环境）
```

## 日志模块

### 基本用法

```typescript
import { LoggerService } from 'src/logger/logger.service';

@Injectable()
export class YourService {
  constructor(private readonly logger: LoggerService) {}

  yourMethod() {
    // 不同级别的日志
    this.logger.debug('这是调试信息', 'YourService');
    this.logger.info('这是普通信息', 'YourService');
    this.logger.warn('这是警告信息', 'YourService');
    this.logger.error('这是错误信息', 'YourService', '错误堆栈信息');

    // 带额外数据的日志
    this.logger.info('用户登录成功', 'YourService', {
      userId: 123,
      ip: '127.0.0.1',
    });

    // 记录详细日志
    this.logger.verbose('详细操作信息', 'YourService');
  }
}
```

### 日志级别

系统支持以下日志级别，按严重程度从低到高排序：

1. `verbose`: 详细日志，通常在开发环境使用
2. `debug`: 调试信息，有助于问题排查
3. `info`: 一般信息，记录正常操作
4. `warn`: 警告信息，表示潜在问题
5. `error`: 错误信息，包含错误堆栈

### 上下文和元数据

- `context`: 指定日志来源，通常是类名或模块名
- `meta`: 附加信息，可以包含任何相关的数据对象

### 请求日志中间件

`RequestLoggerMiddleware` 自动记录每个HTTP请求的详细信息，无需手动配置。该中间件通过实现 `NestMiddleware` 接口，自动处理请求和响应日志。

主要功能：

- 为每个请求生成唯一ID (requestId)
- 记录请求开始和结束时间
- 记录请求方法、URL、IP地址、用户代理等信息
- 记录请求体和响应体（自动移除敏感信息）
- 根据状态码确定日志级别（>=400使用WARN级别，其他使用INFO级别）
- 计算请求处理时间

使用方式：

```typescript
// 在应用模块中配置
@Module({
  imports: [...],
  controllers: [...],
  providers: [...],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(RequestLoggerMiddleware)
      .forRoutes('*');
  }
}
```

输出日志示例：

```
// 请求开始日志
{
  "level": "info",
  "message": "请求开始: GET /api/users",
  "context": "RequestLogger",
  "request": {
    "requestId": "550e8400-e29b-41d4-a716-446655440000",
    "method": "GET",
    "url": "/api/users",
    "ip": "127.0.0.1",
    "userAgent": "Mozilla/5.0...",
    "query": { "page": "1", "limit": "10" },
    "body": {},
    "timestamp": "2023-06-01T12:34:56.789Z"
  }
}

// 请求结束日志
{
  "level": "info",
  "message": "请求结束: GET /api/users 200 45ms",
  "context": "RequestLogger",
  "response": {
    "requestId": "550e8400-e29b-41d4-a716-446655440000",
    "method": "GET",
    "url": "/api/users",
    "statusCode": 200,
    "responseTime": "45ms",
    "timestamp": "2023-06-01T12:34:56.834Z",
    "responseBody": { ... }
  }
}
```

## 数据库模块

### TypeORM 配置

项目使用 TypeORM 作为 ORM 框架。

### 实体定义

```typescript
// src/modules/users/entities/user.entity.ts
import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';

@Entity('users')
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ length: 100, unique: true })
  username: string;

  @Column({ select: false })
  password: string;

  @Column({ default: true })
  isActive: boolean;

  // 定义外键关系示例
  @ManyToOne(() => Role, (role) => role.users, {
    onDelete: 'CASCADE',
    onUpdate: 'CASCADE',
  })
  role: Role;
}
```

- 当存在 ManyToOne 或者 OneToOne 关系时，需在拥有外键的一方设置级联删除和更新。

### 事务用法

项目使用 `TransactionService` 管理数据库事务，确保多个数据库操作要么全部成功，要么全部失败：

```typescript
import { TransactionService } from 'src/database/transaction.service';

@Injectable()
export class UserService {
  constructor(
    private readonly transactionService: TransactionService,
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
  ) {}

  async createUserWithProfile(userData: CreateUserDto) {
    return this.transactionService.executeTransaction(async (manager) => {
      // 使用事务管理器执行操作
      const user = manager.create(User, userData);
      await manager.save(user);

      const profile = manager.create(Profile, {
        userId: user.id,
        ...userData.profile,
      });
      await manager.save(profile);

      return user;
    });
  }
}
```

`TransactionService` 提供 `executeTransaction` 方法，该方法：

1. 自动创建事务
2. 执行传入的回调函数
3. 如果回调成功执行，则提交事务
4. 如果出现错误，则回滚事务并抛出异常
5. 无论成功失败，最终都会释放连接资源

事务使用建议：

- 当一个操作涉及多个实体的创建、更新或删除时，应使用事务
- 事务回调内应使用提供的 `manager` 参数执行数据库操作，而不是注入的 Repository
- 事务回调可以返回任何值，该值将作为 `executeTransaction` 的返回值

## Redis模块

### 基本用法

```typescript
import { RedisService } from 'src/redis/redis.service';

@Injectable()
export class YourService {
  constructor(private readonly redisService: RedisService) {}

  async yourMethod() {
    // 设置键值对
    await this.redisService.set('key', 'value');
    await this.redisService.set('key', 'value', 60); // 60秒过期

    // 获取键值
    const value = await this.redisService.get('key');

    // 删除键
    await this.redisService.delete('key');

    // 检查键是否存在
    const exists = await this.redisService.exists('key');

    // 设置过期时间
    await this.redisService.expire('key', 300); // 5分钟过期

    // 哈希表操作
    await this.redisService.hset('user:1', 'name', 'admin');
    await this.redisService.hset('user:1', 'role', 'admin');

    // 获取哈希表字段
    const name = await this.redisService.hget('user:1', 'name');

    // 获取整个哈希表
    const user = await this.redisService.hgetall('user:1');

    // 直接获取Redis客户端进行更复杂的操作
    const client = this.redisService.getClient();
    await client.incr('counter');
  }
}
```

### 配置Redis

Redis 配置在配置文件中定义：

```yaml
# config/*.yaml
redis:
  host: 'localhost'
  port: 6379
  password: '' # 可选
  db: 0
  keyPrefix: '' # 可选
```

### Redis服务方法

| 方法                      | 说明                | 参数                                             | 返回值                            |
| ------------------------- | ------------------- | ------------------------------------------------ | --------------------------------- |
| `set(key, value, ttl?)`   | 设置键值对          | `key`: 键<br>`value`: 值<br>`ttl?`: 过期时间(秒) | `Promise<void>`                   |
| `get(key)`                | 获取键值            | `key`: 键                                        | `Promise<string \| null>`         |
| `delete(key)`             | 删除键              | `key`: 键                                        | `Promise<number>` 删除的键数量    |
| `exists(key)`             | 检查键是否存在      | `key`: 键                                        | `Promise<boolean>`                |
| `expire(key, ttl)`        | 设置键的过期时间    | `key`: 键<br>`ttl`: 过期时间(秒)                 | `Promise<boolean>` 成功返回true   |
| `hset(key, field, value)` | 设置哈希表字段      | `key`: 哈希表键<br>`field`: 字段<br>`value`: 值  | `Promise<number>`                 |
| `hget(key, field)`        | 获取哈希表字段      | `key`: 哈希表键<br>`field`: 字段                 | `Promise<string \| null>`         |
| `hgetall(key)`            | 获取哈希表所有字段  | `key`: 哈希表键                                  | `Promise<Record<string, string>>` |
| `getClient()`             | 获取Redis客户端实例 | 无                                               | `Redis` 客户端实例                |

### 最佳实践

1. **键名命名规范**

   - 使用冒号分隔不同部分，如：`module:entity:id`
   - 例如：`user:1:profile`、`auth:token:123456`

2. **合理设置过期时间**

   - 对于缓存数据，设置合理的过期时间
   - 避免缓存数据长期占用内存

3. **错误处理**
   - 始终使用 try/catch 包装 Redis 操作
   - Redis 连接错误不应导致整个应用崩溃

```typescript
try {
  await this.redisService.set('key', 'value');
} catch (error) {
  this.logger.error('Redis操作失败', 'YourService', error.stack);
  // 降级处理，如使用数据库查询
}
```

4. **数据序列化**
   - 对于复杂对象，需要手动序列化和反序列化

```typescript
// 存储复杂对象
const user = { id: 1, name: 'admin', roles: ['admin', 'editor'] };
await this.redisService.set('user:1', JSON.stringify(user));

// 读取复杂对象
const userJson = await this.redisService.get('user:1');
const user = userJson ? JSON.parse(userJson) : null;
```

5. **哈希表使用场景**
   - 存储对象的多个字段时，优先使用哈希表
   - 便于单独更新对象的某个字段，而不影响其他字段

## 认证模块

### 认证守卫用法

```typescript
import { JwtAuthGuard } from 'src/common/auth/guards/jwt-auth.guard';
import { RolesGuard } from 'src/common/auth/guards/roles.guard';
import { Roles } from 'src/common/auth/decorators/roles.decorator';

@Controller('users')
export class UserController {
  @Get('profile')
  @UseGuards(JwtAuthGuard)
  getProfile(@Req() req) {
    return req.user;
  }

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('admin')
  create(@Body() createUserDto: CreateUserDto) {
    // 只有admin角色可访问
  }
}
```

### 用户认证流程

```typescript
import { AuthService } from 'src/common/auth/auth.service';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('login')
  async login(@Body() loginDto: LoginDto) {
    const { username, password } = loginDto;
    const user = await this.authService.validateUser(username, password);

    if (!user) {
      throw new UnauthorizedException('用户名或密码错误');
    }

    return this.authService.login(user);
  }

  @Post('refresh')
  @UseGuards(RefreshTokenGuard)
  async refreshToken(@Req() req) {
    const userId = req.user.id;
    const refreshToken = req.user.refreshToken;

    return this.authService.refreshToken(userId, refreshToken);
  }
}
```
